

initial header, always 4 bytes:

0x50, 0x70, commandCode (1-byte), 0x00

bottom 5 bits of commandCode provide the command group
upper 3 bits are command number within the group

having commands in groups makes it easier for the
peekpoke program to determine if the command is available
(both implemented and allowed)

groups  description         commands
0       constant info       getBasicInfo
1       read hub data       readHub
2       write hub data      writeHub
3       cog control         pasmCogInit, cogStop

possible future groups:
- payload exec
- read clock info
- set clock info
- read eeprom
- write eeprom
- read pins
- write pins
- test locks
- use locks
- read cog
- write cog
- use ctra
- use ctrb


getBasicInfo()
--------------

Command code: 0x00 (group 0, command 0)

Command payload, 4 bytes:
                    pos     len     description
                    0-4     3       initial header

Response payload, 12 bytes:
                    pos     len     description
                    0-3     4       initial header
                    4-5     2       par
                    6       1       cog id
                    7       1       padding = 0x00
                    8-11    4       availableGroups mask


readHub(address, count)
-----------------------

Command code: 0x01 (group 1, command 0)

Command payload, 4 bytes:
                    pos     len     description
                    0-3     4       initial header
                    4-5     2       hub address of read start, any alignment
                    6-7     2       count = number of bytes to read, may be zero

Response payload, (4 + count) bytes:
                    pos     len     description
                    0-3     4       initial header
                    4+      count   the bytes read


writeHub(address, data<uint8_t>[])
----------------------------------

Command code: 0x02 (group 2, command 0)

Command payload, (8 + count) bytes:
                    pos     len     description
                    0-3     4       initial header
                    4-5     2       hub address of write start, any alignment
                    6-7     2       count = number of bytes to write, may be zero
                    8+      count   the bytes to write

Response payload, 4 bytes:
                    pos     len     description
                    0-3     4       initial header
 

pasmCogInit(destReg)
--------------------

Command code: 0x03 (group 3, command 0)

Command payload, 8 bytes:
                    pos     len     description
                    0-3     4       initial header
                    4-7     4       destReg in the format expected by the coginit instruction

Response payload, 5 bytes:
                    pos     len     description
                    0-3     4       initial header
                    4       1       result of coginit instruction; bits 0-6: the id of the cog that the hub started,
                                      or would have, if allowed to pick; bit 7: c-flag (1 => no cog available)


cogStop(cogID)
--------------

Command code: 0x23 (group 3, command 1)


Command payload, 5 bytes:
                    pos     len     description
                    0-3     4       initial header
                    4       1       id of cog to stop (upper 5 bits ignored)

Response payload, 5 bytes:
                    pos     len     description
                    0-3     4       initial header
                    4       1       result of cogstop instruction; bits 0-6: id of cog stopped; bit 7: c-flag
                                      (1 => all cogs were running prior to this command being executed)


Command Format
==============

A command always starts with the four byte initial header. Any additional
data required depends on the specific command.


Response Format
===============

All responses have at least four bytes. The first three are always the same as in 
the command. The fourth is a status code -- a zero value indicates a normal response,
and a non-zero value indicates an error response.

Any additional bytes in the payload depend on the specific command and the response
type (normal or error).


Byte-Ordering and PropCR
========================

All multibyte values in both command and response payloads are little-endian.

PeekPoke is designed to use the Crow serial protocol. There are two
implementations of the Crow protocol for the Propeller: PropCrow and PropCR.

The PropCR implementation deviates from the Crow standard in that the device expects
every group of four command payload bytes will be reversed. (This allows
greater speed with less code.) This means the host must correctly order the command
based on the device implementation in use.

The Python CrowHost implementation has an optional "propcr_order=True" argument
to send_command that will perform this reordering automatically, but the host must
still decide if it is necessary.

There is an error number, PossibleIncorrectOrder, that the device
can return if it suspects it is getting a valid PeekPoke command but with
the incorrect byte ordering -- either a PropCR-based implementation getting a
standard order payload, or a PropCrow-based implementation getting a reversed
order payload. If the host receives such an error response it should try resending
the command using the alternative option.  The getBasicInfo command is a good
test command since it does not change any values on the Propeller. The admin command
getDeviceInfo (on port 0) can also be used to determine the device implementation.


Error Responses
===============

The fourth byte of the response provides a status code, which in the case of errors
will be non-zero:

   (0 - not possible, only non-zero numbers represent error conditions)
    1 - UnspecifiedError
    2 - PossibleIncorrectOrder
    3 - CommandNotAvailable
    4 - CommandNotPermitted
    5 - CommandNotImplemented
    6 - MissingData
    7 - InvalidArguments
    8 - InvalidCommand
    9 - UnknownCommand
    + - reserved, host should present as "Unknown Error" or "Unknown Error Number XX"

The device implementation is free to choose any error number to describe an error.
Some errors can be described by a variety of numbers. For example, a command that
is not implemented is also not available. In fact, any error qualifies as an
'unspecified error'. Having these choices allows a device implementation to be
simple at the cost of providing less specific error information.

Future versions may allow more detailed error information. V2 PeekPoke host
implementations must ignore everything past the status byte.

